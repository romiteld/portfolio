# Cursor Rules

## Project Patterns

### File Organization
1. Page Components:
   - Located in app/[feature]/page.tsx
   - Use server components by default
   - Client components in separate files
   - Layout components in layout.tsx

2. Component Structure:
   - Shared components in app/components
   - Feature-specific components in app/[feature]/components
   - Hooks in app/hooks or feature-specific hooks/
   - Utils in app/utils

3. API Routes:
   - Located in app/api/[feature]/route.ts
   - Use Next.js Route Handlers
   - Include input validation
   - Proper error handling

### Naming Conventions
1. Files:
   - React components: PascalCase.tsx
   - Utilities: camelCase.ts
   - Constants: UPPER_CASE.ts
   - Types: PascalCase.types.ts

2. Components:
   - Component names: PascalCase
   - Props interfaces: ComponentNameProps
   - Styles: component-name.module.css

3. Functions:
   - Handlers: handleEventName
   - Async functions: verbNoun
   - Hooks: useNoun

### Code Style
1. TypeScript:
   - Strict mode enabled
   - Explicit return types
   - Interface over type
   - Proper type imports

2. React:
   - Functional components
   - Hooks for state
   - Memoization when needed
   - Props destructuring

3. CSS:
   - Tailwind classes
   - CSS modules for custom styles
   - Mobile-first approach
   - BEM naming for custom classes

### Demo Guidelines
1. Structure:
   - Self-contained in demos/[demo-name]
   - Shared components when possible
   - Proper loading states
   - Error boundaries

2. Performance:
   - Lazy loading
   - Optimized assets
   - Proper caching
   - Analytics events

3. Documentation:
   - README.md in demo folder
   - Code comments
   - Type documentation
   - Usage examples

## Critical Paths
1. Authentication:
   - Admin routes protection
   - API route security
   - Session management
   - Error handling

2. Form Handling:
   - React Hook Form
   - Zod validation
   - Error messages
   - Loading states

3. Image Processing:
   - Sharp optimization
   - WebP conversion
   - Lazy loading
   - Placeholder handling

4. RL Training Loop (Offline - Python):
   - **Environment Activation:** Critical - must activate the correct conda environment (`chess_rl`) before running `main.py`.
   - **Execution:** Run `python main.py` from within `chess-rl-training-local` directory.
   - **Phases:** Iterative loop of self-play (CPU-bound, MCTS-heavy) -> training (GPU-bound).
   - **Output:** Generates `.npz` game data and `.pth` model checkpoints in `runs/run_{timestamp}/`.
   - **Final Model:** Exports `model.onnx` for inference API.

## Known Challenges
1. Performance:
   - Large image optimization
   - Demo loading times
   - Initial page load
   - Font loading

2. Security:
   - API key management
   - Rate limiting
   - Input sanitization
   - Error exposure

3. Development:
   - Type consistency
   - State management
   - Testing coverage
   - Documentation maintenance

4. RL Training:
   - **CPU Bottleneck:** Self-play phase is heavily CPU-bound due to MCTS, leading to low GPU utilization during this phase despite model evaluations happening on GPU.
   - **Training Time:** Multi-iteration process is lengthy (hours/days).
   - **Environment Setup:** Ensuring correct conda environment activation is crucial.

## Tool Usage
1. Development:
   - VS Code
   - ESLint
   - Prettier
   - TypeScript

2. Testing:
   - Jest
   - React Testing Library
   - Cypress
   - Lighthouse

3. Deployment:
   - Vercel
   - GitHub Actions
   - Environment management
   - Analytics tracking 